<template>
  <div id="discover-banner">
    <div
      name="banner"
      class="transition-group"
    >
      <div
        class="pic-container"
        :key="pic.bannerId"
        v-for="pic in loopPics"
        @pointerdown="pointerDown"
        @pointerup="pointerUp"
        @pointermove="pointerMove"
        ref="pics"
      >
        <img
          alt="轮播图片"
          :src="pic.pic"
          @dragstart.prevent
        >
        <span
          class="type-title"
          :type="pic.typeTitle"
        >{{ pic.typeTitle }}</span>
      </div>
    </div>
    <div class="dot-container">
      <div
        v-for="dot in dots"
        :key="dot"
        :class="['dot', {'current-dot': dot===currentIndex}]"
        :current-dot="dot===currentIndex"
      ></div>
    </div>
  </div>
</template>

<script>
import fetchJSON from '@/functions/fetchJSON.js';
export default {
  data: function() {
    return {
      banners: [],
      loopPics: [],
      dots: [],
      currentIndex: 0,
      intervalID: 0,
      amount: 0,
      isPointerDown: false,
      originalLeft: 0,
      picReady: false,
    };
  },

  created: function() {
    fetchJSON('/banner?type=2')
      .then((res) => {
        console.log(res);
        this.banners = res.banners;
        this.amount = this.banners.length;
        this.loopPics.push(this.banners.pop());
        this.loopPics.push(this.banners.shift());
        this.loopPics.push(this.banners.shift());
        console.log(this.loopPics);
        this.currentIndex = 0;
        for (let i = 0; i < this.amount; i++) {
          this.dots[i] = i;
        }
        this.picReady = true;
        return this.$nextTick();
      })
      .then(() => {
        this.originalLeft = this.$refs.pics[1].getBoundingClientRect().left;
      });
  },

  mounted: function() {
    this.$nextTick()
      .then(() => {
        this.loop();
      });
  },

  methods: {
    loop() {
      this.intervalID = setInterval(() => {
        this.slide('right');
      }, 8000);
    },

    slide(dir) {
      // use FLIP to animate(first, last, invert, play)
      const oldLeft = [];
      const newLeft = [];
      const [...movings] = this.$refs.pics;
      // record the left coordinate before moving(first)
      movings.forEach((item) => {
        oldLeft.push(getLeft(item));
      });
      if (dir === 'left') {
        // move the red dot to the next right position by increasing index
        this.currentIndex = ++this.currentIndex % this.amount;
        // add a new pic to the right and remove the most left pic
        this.loopPics.push(this.banners.shift());
        this.banners.push(this.loopPics.shift());
      } else if (dir === 'right') {
        // similar to the 'left' process but opposite in direction
        this.currentIndex = (this.currentIndex - 1 + this.amount) % this.amount;
        this.loopPics.unshift(this.banners.pop());
        this.banners.unshift(this.loopPics.pop());
      }

      // wait the view to change according to the change of loopPics
      this.$nextTick()
        .then(() => {
          movings.forEach((item, i) => {
            // clear all the style (generated by pointermove)
            item.style = '';
            // get the final position after moving(last)
            newLeft.push(getLeft(item));
            // move it to its before-moving position(invert)
            item.style.transform = `translateX(${oldLeft[i] - newLeft[i]}px)`;
          });

          // flush the browser rendering to force reflow
          this._reflow = document.body.offsetHeight;

          // add transition class and clear all styles to animate(play)
          movings.forEach((item) => {
            item.classList.add('banner-move');
            item.addEventListener('transitionend', removeMoveClass);
            item.style = '';
          });
        });

      // auxilary functions
      function removeMoveClass(event) {
        console.log('banner-remove');
        event.target.classList.remove('banner-move');
        event.target.removeEventListener('transitionend', removeMoveClass);
      }
      function getLeft(el) {
        return el.getBoundingClientRect().left;
      }
    },

    pointerDown(event) {
      // const offsetX = event.offsetX;
      // console.log(offsetX);
      const currentLeft = event.target.getBoundingClientRect().left;
      console.log(currentLeft);
      for (const pic of this.$refs.pics) {
        pic.dispatchEvent(new TransitionEvent('transitionend'));
      }
      //console.log(event.target);
      const targetLeft = event.target.getBoundingClientRect().left;
      console.log(targetLeft);
      //console.log(targetLeft);
      this.isPointerDown = true;
      event.target.setPointerCapture(event.pointerId);
      //console.log(event.target);

      //this.relativeX = event.clientX - targetLeft - offsetX;
      this.relativeX = currentLeft - targetLeft;
      //console.log(event.offsetX);
      //console.log(offsetX);
      //console.log(event.clientX);
      //console.log(targetLeft);
      console.log(this.relativeX);
      this.mouseDownX = event.clientX;
      for (const pic of this.$refs.pics) {
        pic.style = `transform:translateX(${this.relativeX}px)`;
      }
      clearInterval(this.intervalID);
    },

    pointerUp(event) {
      if (event.target.hasPointerCapture(event.pointerId)) {
        this.isPointerDown = false;
        const mouseMoveX = event.clientX - this.mouseDownX;
        if (mouseMoveX > 50) {
          this.slide('right');
        } else if (mouseMoveX < -50) {
          this.slide('left');
        } else {
          for (const pic of this.$refs.pics) {
            pic.classList.add('banner-move');
            pic.addEventListener('transitionend', () => {
              pic.classList.remove('banner-move');
            });
          }
          for (const pic of this.$refs.pics) {
            pic.style = '';
          }
        }

        this.loop();
        console.log(event.target);
      }
    },

    pointerMove(event) {
      if (this.isPointerDown) {
        const mouseMoveX = event.clientX - this.mouseDownX;
        for (const pic of this.$refs.pics) {
          pic.style = `transform:translateX(${this.relativeX + mouseMoveX}px)`;
        }
      }
    },
  }
};
</script>

<style scoped>
#discover-banner {
  width: 100%;
  max-width: 45rem;
  overflow: hidden;
  height: 40vw;
  max-height: 18rem;
  grid-row: banner;
  place-self: center;
  display: grid;
  grid-template-columns: [start] 1fr [end];
  grid-template-rows: [start] 1fr [dot-start] 2rem [dot-end end];
  justify-items: center;
  justify-content: space-around;
  user-select: none;
}

.transition-group {
  grid-row: start / end;
  grid-column: start / end;
  width: 300%;
  height: 100%;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  align-items: center;
  justify-items: center;
}

.pic-container {
  height: 90%;
  width: 90%;
  grid-row: auto;
  border-radius: 1rem;
  display: grid;
  overflow: hidden;
  grid-template-rows: [start] 1fr [title-start] max-content [title-end end];
  grid-template-columns: [start] 1fr [title-start] max-content [title-end end];
}

.pic-container img {
  grid-row: start / end;
  grid-column: start / end;
  width: 100%;
  height: 100%;
  object-fit: cover;
  touch-action: none;
}

.type-title {
  grid-row: title-start / title-end;
  grid-column: title-start / title-end;
  background-color: #fc5244;
  color: white;
  font-size: 0.8rem;
  padding: 0.2rem 0.6rem;
  border-radius: 1rem 0 1rem 0;
  user-select: none;
}

.type-title[type="数字专辑"] {
  background-color: #43a5f0;
}

.banner-move {
  transition: transform 1000ms;
}

.banner-leave-active {
  opacity: 0;
  position: absolute;
}

.dot-container {
  grid-row: dot-start / dot-end;
  grid-column: start / end;

  width: 30%;
  min-width: 10rem;
  display: grid;
  grid-template-rows: 1fr;
  grid-template-columns: repeat(auto-fit, 1rem);
  justify-content: space-around;
}

.dot {
  height: 0.5rem;
  width: 0.5rem;
  background-color: #ddd;
  border-radius: 50%;
  z-index: 10;
  transition: background-color, 200ms;
}

.current-dot {
  background-color: var(--app-color);
}
</style>
